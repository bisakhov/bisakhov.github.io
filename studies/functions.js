
// FUNCTION is a reusable block of code that accepts inputs, processes those inputs and returns
// a new data value. 

//Defining functions
function name (parameter) {
    'function body'
    'function body'
    return 'newData';
}

//Functions consist of four parts:

// 1. Name
// 2. Parameter(s) - placeholders for arguments that are later passed or given to function at
// call time. It is OPTIONAL 
// 3. Function body (where code runs)
// 4. Return Statement - stops execution of that function and returns/pulls value from that function.
// It is OPTIONAL.

// Functions follow IOCE logic which answers the following questions:
// I - Inputs --> what data type is being passed into this function;
// O - Outputs --> what should this function return?
// C - Constraints --> are there any specific instructions that involve how I build this function?
// E - Edge cases --> what conditions do you have to meet to make sure I am offering 
// the proper output?

//To call the function, we just type the name of the function with arguments to be inserted
//inside brackets
//ex: name(a, b);

//Functions can be called before they are declared since they are hoisted first!

//Functions can be assigned to a variable (the purpose is to be able to use whatever new data
//generated by the function from a local scope to a global scope so that it can be easily accessed)
//ex.

//var myName = name (a, b);


//A function can access all variables defined inside the function, like this:

function myFunction() {
  var a = 4;
  return a * a;
}

//But a function can also access variables defined outside the function, like this:
var a = 4;
function myFunction() {
  return a * a;
}

//Nested Functions

// All functions have access to the global scope.  

// In fact, in JavaScript, all functions have access to the scope "above" them.

// JavaScript supports nested functions. Nested functions have access to the scope "above" them.

// In this example, the inner function plus() has access to the counter variable 
// in the parent function:

function add() {
  var counter = 0;
  function plus() {counter += 1;}
  plus();   
  return counter;
}

//JavaScript Closures
var add = function () {
  var counter = 0;
  return function () {counter += 1; return counter}
};

add();
add();
add();

// the counter is now 3

// The variable add is assigned to the return value of a self-invoking function.

// The self-invoking function only runs once. It sets the counter to zero (0), 
// and returns a function expression.

// This way add becomes a function. The "wonderful" part is that it can access 
// the counter in the parent scope.

// This is called a JavaScript closure. It makes it possible for a function to 
// have "private" variables.

// The counter is protected by the scope of the anonymous function, and can only
// be changed using the add function.
