
// FUNCTION is a reusable block of code that accepts inputs, processes those inputs and returns
// a new data value. 

//Defining functions
function name (parameter) {
    'function body'
    'function body'
    return 'newData';
}

//Functions consist of four parts:

// 1. Name
// 2. Parameter(s) - placeholders for arguments that are later passed or given to function at
// call time. It is OPTIONAL
//*** PARAMETERS vs ARGUMENTS ==> parameters are placeholders for arguments that are passed at function call time

// 3. Function body (where code runs)
// 4. Return Statement - stops execution of that function and returns/pulls value from that function.
// It is OPTIONAL.

// Functions follow IOCE logic which answers the following questions:
// I - Inputs --> what data type is being passed into this function;
// O - Outputs --> what should this function return?
// C - Constraints --> are there any specific instructions that involve how I build this function?
// E - Edge cases --> what conditions do you have to meet to make sure I am offering 
// the proper output?

//To call the function, we just type the name of the function with arguments to be inserted
//inside brackets
//ex: name(a, b);

function myFunction(p1, p2) {
  return p1 * p2;   // The function returns the product of p1 and p2
}

//function call:
myFunction(3, 5); //returns 15 
//p1 and p2 are parameters & 3 and 5 are corresponding arguments

// Declaration:  function myFunc(...) { ... }
// begins with keyword “function” (‘sibling’ of var declarations)
// is always named

// Expression:  Anything else. For example…
// var myFunc = function() { }; // in variable assignments
// timeout(function timesUp() { }, 1000); // callbacks

//HOISTING - is a process where an interpreter loads variable and function declarations into memory
//during the compile phase before executing the code.

//Variables aren't given value until assigned (for more info, look at variables.js!)
//Functions are assigned value AT ALL TIMES.

// Function hoisting
// Like variables, the JavaScript engine also hoists the function declarations. It moves the function 
// declarations to the top of the script. For example:

let x = 20,
    y = 10;

let result = add(x,y);
console.log(result);

function add(a, b){
return a + b;
}

// In this example, we called the add() function before defining it. 
// The above code is equivalent to the following (commented here to avoid test errors):
////////////////////
// function add(a, b){
//     return a + b;
// }

// let x = 20,
//     y = 10;

// let result = add(x,y);
// console.log(result);
/////////////////////////

// During the creation phase of the execution context, the JavaScript engine places the add() function 
// declaration in the heap memory. To be precise, the JavaScript engine creates an object 
// of the Function type and a function reference called add that refers to the function object.

//Functions can be called before they are declared since they are hoisted first!

//Function calls can be assigned to a variable (the purpose is to be able to use whatever new data
//generated by the function from a local scope to a global scope so that it can be easily accessed)
//ex.

//var myName = name (a, b);


//A function can access all variables defined inside the function, like this:

function myFunction() {
  var a = 4;
  return a * a;
}

//But a function can also access variables defined outside the function, like this:
var a = 4;
function myFunction() {
  return a * a;
}

//NESTED FUNCTIONS

// All functions have access to the global scope.  

// In fact, in JavaScript, all functions have access to the scope "above" them.

// JavaScript supports nested functions. Nested functions have access to the scope "above" them.

// In this example, the inner function plus() has access to the counter variable 
// in the parent function:

function add() {
  var counter = 0;
  function plus() {counter += 1;}
  plus();   
  return counter;
}

//JavaScript Closures
var add = function () {
  var counter = 0;
  return function () {counter += 1; return counter}
};

add();
add();
add();

// the counter is now 3

// The variable add is assigned to the return value of a self-invoking function.

// The self-invoking function only runs once. It sets the counter to zero (0), 
// and returns a function expression.

// This way add becomes a function. The "wonderful" part is that it can access 
// the counter in the parent scope.

// This is called a JavaScript closure. It makes it possible for a function to 
// have "private" variables.

// The counter is protected by the scope of the anonymous function, and can only
// be changed using the add function.
